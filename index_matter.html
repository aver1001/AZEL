<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>로또 볼 추첨기 (2D 물리)</title>
  <style>
    html,body{height:100%}
    body{margin:0;background:#0b1020;color:#e5e7eb;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica Neue,Arial,"Apple SD Gothic Neo","Malgun Gothic",sans-serif;overflow:hidden}
    header{display:flex;gap:8px;align-items:center;flex-wrap:wrap;padding:10px 12px;background:rgba(17,24,39,.6);backdrop-filter:blur(6px);border-bottom:1px solid rgba(255,255,255,.06)}
    label{color:#9ca3af}
    button{appearance:none;border:1px solid rgba(255,255,255,.2);background:#1f2a44;color:#e5e7eb;padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer}
    /* layout */
    #content{display:flex;height:100vh}
    #leftPane{width:40%;min-width:280px;max-width:75vw;background:rgba(17,24,39,.6);border-right:1px solid rgba(255,255,255,.06);display:flex}
    #divider{width:6px;cursor:col-resize;background:rgba(255,255,255,.08)}
    #divider:hover{background:rgba(255,255,255,.16)}
    #stage{position:relative;height:100%;flex:1;background:radial-gradient(1200px 800px at 60% 40%, #10172a 0%, #0b1020 55%, #080d1a 100%);overflow:hidden}
    #stage::before{content:"";position:absolute;inset:-10%;background:radial-gradient(600px 380px at 65% 35%, rgba(255,255,255,.08), rgba(255,255,255,0) 60%);pointer-events:none;z-index:0}
    #stage canvas{position:absolute;inset:0;z-index:1}
    #tension{position:absolute;inset:0;z-index:2;pointer-events:none;opacity:0;transition:opacity .12s}
    #tension::before{content:"";position:absolute;inset:-10%;background:radial-gradient(ellipse at center, rgba(0,0,0,0) 40%, rgba(0,0,0,.35) 80%, rgba(0,0,0,.55) 100%)}
    /* Brand logo */
    #brandLogo{position:absolute;left:12px;top:12px;max-width:200px;max-height:72px;z-index:14;opacity:.98;pointer-events:none;background:rgba(0,0,0,.35);padding:6px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.35)}
    /* Drum decor overlays */
    #drumDecor{position:absolute;inset:0;z-index:2;pointer-events:none}
    #drumFrame,#drumGlass{position:absolute;transform:translate(-50%,-50%);border-radius:50%}
    /* Make frame center transparent so canvas (ball colors) stays visible */
    #drumFrame{
      box-shadow:0 10px 30px rgba(0,0,0,.45), inset 0 6px 14px rgba(255,255,255,.25), inset 0 -10px 18px rgba(0,0,0,.5);
      background: transparent; /* was a solid radial gradient that hid the balls */
      border:2px solid rgba(255,255,255,.18)
    }
    #drumGlass{background:
      radial-gradient(closest-side at 50% 50%, rgba(255,255,255,0) 0%, rgba(255,255,255,.06) 70%, rgba(255,255,255,.12) 100%),
      linear-gradient(135deg, rgba(255,255,255,.22) 0%, rgba(255,255,255,.06) 22%, rgba(255,255,255,0) 42%),
      radial-gradient(140% 100% at 65% 30%, rgba(62,121,194,.05) 0%, rgba(62,121,194,0) 60%);
      opacity:.14;}
    #confetti{position:absolute;inset:0;z-index:12;pointer-events:none}
    #countdown{position:absolute;inset:0;display:grid;place-items:center;font-weight:900;font-size:clamp(42px,9vw,88px);color:#fff;pointer-events:none;opacity:0;transition:opacity .2s;z-index:4}
    #countdown.show{opacity:.95}
    #countdown.tick{animation:pop .32s ease}
    @keyframes pop{0%{transform:scale(1);color:#fff}35%{transform:scale(1.18);color:#f87171}100%{transform:scale(1);color:#fff}}
    #winner{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:10}
    #winner.show{display:flex}
    .panel{background:rgba(17,24,39,.8);border:1px solid rgba(255,255,255,.1);border-radius:12px;padding:16px;text-align:center}
    .ball{width:120px;height:120px;border-radius:50%;margin:10px auto;display:grid;place-items:center;font-size:36px;font-weight:900;color:#0a0a0a;box-shadow:inset 0 -10px 16px rgba(0,0,0,.35),inset 0 10px 18px rgba(255,255,255,.25),0 10px 26px rgba(0,0,0,.45)}

    /* settings modal */
    .modal{position:fixed;inset:0;display:none;z-index:20;background:rgba(0,0,0,.5)}
    .modal.show{display:grid;place-items:center}
    .modal .card{width:min(92vw,880px);background:rgba(17,24,39,.95);border:1px solid rgba(255,255,255,.12);border-radius:14px;padding:16px;box-shadow:0 20px 60px rgba(0,0,0,.45)}
    .modal .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .modal textarea{width:100%;min-height:200px;resize:vertical;box-sizing:border-box;background:#0f172a;color:#e5e7eb;border:1px solid rgba(255,255,255,.15);border-radius:10px;padding:12px 14px;font-size:14px;line-height:1.4}
    .modal button{appearance:none;border:1px solid rgba(255,255,255,.2);background:#1f2a44;color:#e5e7eb;padding:10px 14px;border-radius:10px;font-weight:700;cursor:pointer}
    .modal .hint{color:#9ca3af;font-size:13px}
    .modal .close{margin-left:auto;background:#374151;border-color:#4b5563}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
</head>
<body>
  <div id="content">
    <div id="leftPane">
      <div class="uploadPanel" style="display:flex;flex-direction:column;gap:12px;padding:12px;flex:1">
        <textarea id="headline" placeholder="텍스트를 입력하세요"
               style="width:100%;box-sizing:border-box;min-height:110px;max-height:110px;resize:none;padding:12px 14px;border-radius:10px;border:1px solid rgba(255,255,255,.2);background:#0f172a;color:#e5e7eb;font-weight:700;text-align:center;white-space:nowrap;overflow:hidden"></textarea>
        <div id="previewWrap" class="previewWrap" title="이미지를 드래그&드롭하거나 클릭하여 업로드, 드래그로 위치 조정"
             style="flex:1;display:grid;place-items:center;border:1px dashed rgba(255,255,255,.15);border-radius:10px;overflow:hidden;background:rgba(0,0,0,.15);cursor:pointer;position:relative;user-select:none;background-repeat:no-repeat;background-size:cover;background-position:50% 50%;transition:border-color .15s, background-color .15s">
          <img id="preview" alt="업로드 이미지" style="width:120%;height:120%;object-fit:cover;object-position:50% 50%;display:block;pointer-events:none" />
        </div>
        <input id="upload" type="file" accept="image/*" hidden>
      </div>
    </div>
    <div id="divider" title="좌우 구역 크기 조절"></div>
    <div id="stage">
      <div id="drumDecor"><div id="drumFrame"></div><div id="drumGlass"></div></div>
      <div id="tension"></div>
      <div id="controls" style="position:absolute;top:10px;right:10px;z-index:6;background:rgba(17,24,39,.7);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.12);border-radius:12px;display:flex;gap:10px;align-items:center;padding:10px 12px">
        <label style="color:#9ca3af;white-space:nowrap">크기 <input id="drumSize" type="range" min="18" max="42" step="1" /></label>
        <label style="color:#9ca3af">바람 <input id="wind" type="range" min="0" max="100" value="60" /></label>
        <button id="generate">생성</button>
        <button id="draw">추첨</button>
        <button id="openSettings" title="설정">설정</button>
      </div>
      <img id="brandLogo" alt="브랜드 로고" />
      <canvas id="confetti" style="position:absolute;inset:0;pointer-events:none;z-index:12"></canvas>
      <div id="countdown">10</div>
      <div id="winner"><div class="panel"><div id="winnerBall" class="ball">?</div><div>당첨!</div></div></div>
      <div id="labels" style="position:absolute;inset:0;pointer-events:none;z-index:3"></div>
    </div>
  </div>
  <!-- Settings Modal -->
  <div id="settingsModal" class="modal" aria-hidden="true">
    <div class="card">
      <div class="row" style="margin-bottom:10px">
        <div style="font-weight:700">설정: 공 숫자 목록</div>
        <button id="settingsClose" class="close">닫기</button>
      </div>
      <div class="hint" style="margin-bottom:8px">원하는 "공에 표시할 숫자" 목록을 입력하세요. 콤마 또는 줄바꿈으로 구분합니다.</div>
      <textarea id="stNumbers" placeholder="예) 3, 7, 11, 24, 36, 41"></textarea>
      <div class="row" style="margin-top:10px">
        <label class="hint">공 개수(N) <input id="stCount" type="number" min="1" max="200" value="24" style="width:92px"/></label>
        <span class="hint">메인 화면의 개수와 일치시키면 편리합니다.</span>
      </div>
      <div class="row" style="margin-top:10px">
        <label class="hint">출구 방향
          <select id="stExitDir" style="margin-left:6px">
            <option value="right">오른쪽</option>
            <option value="bottom">아래</option>
          </select>
        </label>
        <label class="hint" style="margin-left:12px">사운드 음량
          <input id="stVolume" type="range" min="0" max="100" value="80" style="vertical-align:middle;margin-left:6px"/>
        </label>
        <button id="stTestSound" class="hint" style="margin-left:6px">테스트</button>
      </div>
      <div class="row" style="margin-top:12px">
        <button id="stSave">저장</button>
        <button id="stSaveAndGen">저장하고 생성</button>
        <button id="stClear">비우기</button>
        <button id="stFill">1부터 N개 채우기</button>
      </div>
      <div class="row" style="margin-top:12px">
        <label class="hint">브랜드 로고 업로드
          <input id="stLogo" type="file" accept="image/*" style="margin-left:6px"/>
        </label>
        <button id="stClearLogo">로고 제거</button>
      </div>
    </div>
  </div>

  <script>
  (function(){
    const Engine = Matter.Engine, Runner = Matter.Runner, World = Matter.World,
          Bodies = Matter.Bodies, Body = Matter.Body, Composite = Matter.Composite,
          Events = Matter.Events, Vector = Matter.Vector, Render = Matter.Render;

    const stage = document.getElementById('stage');
    const btnGen = document.getElementById('generate');
    const btnStart = document.getElementById('start');
    const btnDraw = document.getElementById('draw');
    const inputCount = document.getElementById('count');
    const inputWind = document.getElementById('wind');
    
    const countdownEl = document.getElementById('countdown');
    const winnerEl = document.getElementById('winner');
    const winnerBall = document.getElementById('winnerBall');
    const tensionEl = document.getElementById('tension');
    const confettiCanvas = document.getElementById('confetti');
    const confettiCtx = confettiCanvas ? confettiCanvas.getContext('2d') : null;
    const uploadInput = document.getElementById('upload');
    const previewImg = document.getElementById('preview');
    const previewWrap = document.getElementById('previewWrap');
    const headlineInput = document.getElementById('headline');
    const contentEl = document.getElementById('content');
    const divider = document.getElementById('divider');
    const btnOpenSettings = document.getElementById('openSettings');
    const drumSizeInput = document.getElementById('drumSize');
    const brandLogo = document.getElementById('brandLogo');
    // modal refs
    const settingsModal = document.getElementById('settingsModal');
    const settingsClose = document.getElementById('settingsClose');
    const stNumbers = document.getElementById('stNumbers');
    const stCount = document.getElementById('stCount');
    const stSave = document.getElementById('stSave');
    const stSaveAndGen = document.getElementById('stSaveAndGen');
    const stClear = document.getElementById('stClear');
    const stFill = document.getElementById('stFill');
    const stExitDir = document.getElementById('stExitDir');
    const stVolume = document.getElementById('stVolume');
    const stLogo = document.getElementById('stLogo');
    const stClearLogo = document.getElementById('stClearLogo');
    const stTestSound = document.getElementById('stTestSound');

    const engine = Engine.create({ enableSleeping: true });
    engine.gravity.y = 1.0; // 더 가볍게
    const runner = Runner.create();
    const render = Render.create({ element: stage, engine, options: { width: stage.clientWidth, height: stage.clientHeight, background: '#0b1020', wireframes: false, pixelRatio: window.devicePixelRatio } });
    Render.run(render);
    Runner.run(runner, engine);

    let drum = { parts: [], gate: [], basket: [], sensor: null, plug: null };
    let marbles = []; // {body, id}
    let running = false; let drawn = null; let countdownTimer = null;
    let gateOpened = false; let gateOpenAt = 0; let selectedId = null; let awaitingExit = false;
    const sensorTime = new Map(); // marble.body.id -> timestamp when passed gate sensor
    let windStrength = 0.6; // 0..1
    let drumRatio = 0.28;   // portion of min(W,H)
    let exitDir = 'right';  // 'right' | 'bottom'
    let audioVolume = 1.0;  // 0..1
    // slow motion control
    let slowMoActive = false; let slowMoStart = 0; let slowMoMin = 0.35; let slowMoDur = 900; // ms
    // held slow-mo until winner
    let slowHoldActive = false; let slowHoldScale = 0.35; let slowHoldTimer = 0;
    // triggerSlowMo(min, dur) or triggerSlowMo(dur) for backward-compat
    function triggerSlowMo(minOrDur=0.35, dur=900){
      slowMoActive = true; slowMoStart = performance.now();
      if (typeof minOrDur === 'number' && minOrDur > 1 && dur === 900){
        // called as triggerSlowMo(duration)
        slowMoMin = 0.35; slowMoDur = Math.max(200, minOrDur|0);
      } else {
        slowMoMin = Math.max(0.05, Math.min(1, Number(minOrDur)||0.35));
        slowMoDur = Math.max(200, dur|0);
      }
    }
    // countdown tension
    let countdownActive = false; let countdownEnd = 0; let countdownTotal = 0; let countdownBoost = 0; let lastWhole = 0;
    // zoom-to-exit camera control
    let zoomActive = false; let zoomStart = 0; let zoomDur = 900; let zoomFrom = 1; let zoomTo = 1.18; let zoomOrigin = { x: 0, y: 0 };
    function getExitPoint(){
      if (drum && drum.chute && drum.chute.start) return { x: drum.chute.start.x, y: drum.chute.start.y };
      if (Rinfo){ return exitDir === 'right' ? { x: Rinfo.cx + Rinfo.R + 8, y: Rinfo.cy } : { x: Rinfo.cx, y: Rinfo.cy + Rinfo.R + 8 }; }
      return { x: (render.options.width||0)/2, y: (render.options.height||0)/2 };
    }
    function startZoomToExit(scale=1.18, dur=900){
      const p = getExitPoint();
      zoomActive = true; zoomStart = performance.now(); zoomDur = dur; zoomFrom = 1; zoomTo = scale; zoomOrigin = p;
      if (stage) stage.style.transformOrigin = `${p.x}px ${p.y}px`;
    }
    function clearZoom(){
      zoomActive = false;
      if (stage){ stage.style.transformOrigin = '50% 50%'; stage.style.transform = ''; }
    }
    // audio
    let audioCtx = null;
    function ensureAudio(){ if (!audioCtx) { try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){} } }
    function beep(freq=880, ms=120, gain=0.06){
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const VOL_BOOST = 4.0; // higher headroom for max loudness
      const vol = Math.min(1, (audioVolume||0) * gain * VOL_BOOST);
      if (vol<=0) return;
      osc.type='sine'; osc.frequency.value = freq;
      g.gain.value = vol; g.gain.setValueAtTime(vol, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t + ms/1000);
      osc.connect(g); g.connect(audioCtx.destination);
      osc.start(t); osc.stop(t + ms/1000 + 0.02);
    }

    // Simple fanfare on win
    function playFanfare(){
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const master = audioCtx.createGain(); master.gain.value = 0.50 * (audioVolume||0); master.connect(audioCtx.destination);
      function tone(start, freq, dur=0.22, type='triangle', vol=1){
        const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
        o.type = type; o.frequency.value = freq; g.gain.value = 0; o.connect(g); g.connect(master);
        g.gain.setValueAtTime(0.0001, start);
        g.gain.exponentialRampToValueAtTime(0.8*vol, start + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, start + dur);
        o.start(start); o.stop(start + dur + 0.05);
      }
      // Arpeggio up, then final chord
      const C5=523.25, E5=659.25, G5=783.99, C6=1046.5;
      tone(now + 0.00, G5, 0.18, 'square', 0.9);
      tone(now + 0.12, A5=880.0, 0.18, 'square', 0.9);
      tone(now + 0.24, B5=987.77, 0.18, 'square', 0.9);
      // Final chord
      tone(now + 0.44, C5, 0.6, 'triangle', 1.0);
      tone(now + 0.44, E5, 0.6, 'triangle', 0.9);
      tone(now + 0.44, G5, 0.6, 'triangle', 0.9);
      tone(now + 0.44, C6, 0.6, 'triangle', 0.8);
      // Short noise burst for sparkle
      try{
        const n = audioCtx.createBufferSource();
        const len = Math.floor(audioCtx.sampleRate * 0.25);
        const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i=0;i<len;i++){ data[i] = (Math.random()*2-1) * Math.exp(-i/ (audioCtx.sampleRate*0.12)); }
        n.buffer = buf;
        const ng = audioCtx.createGain(); ng.gain.value = 0.08; n.connect(ng); ng.connect(master);
        n.start(now + 0.44);
      }catch(e){}
    }


    function rgb(h){ const c = `hsl(${h} 70% 55%)`; const ctx = document.createElement('canvas').getContext('2d'); ctx.fillStyle = c; return ctx.fillStyle; }
    // utilities: slow-mo hold control
    function startSlowHold(scale=0.35){ slowHoldActive = true; slowHoldScale = Math.max(0.05, Math.min(1, Number(scale)||0.35)); }
    function stopSlowHold(){ slowHoldActive = false; if (engine && engine.timing) engine.timing.timeScale = 1; }

    // drum size load/save
    (function(){
      try{
        const s = localStorage.getItem('lotto.drumRatio');
        if (s){ const v = parseFloat(s); if (Number.isFinite(v) && v>0.1 && v<0.8) drumRatio = v; }
      }catch(e){}
      if (drumSizeInput){
        const toSlider = (r)=> Math.round(r*100);
        const toRatio = (v)=> Math.max(0.18, Math.min(0.42, (parseInt(v,10)||28)/100));
        drumSizeInput.value = String(toSlider(drumRatio));
        drumSizeInput.addEventListener('input', ()=>{
          drumRatio = toRatio(drumSizeInput.value);
          localStorage.setItem('lotto.drumRatio', String(drumRatio));
          generate();
        });
      }
    })();

    // exit direction and audio volume load
    (function(){
      try{
        const d = localStorage.getItem('lotto.exitDir');
        if (d === 'right' || d === 'bottom') exitDir = d;
      }catch(e){}
      try{
        const v = parseFloat(localStorage.getItem('lotto.audioVol')||'');
        if (Number.isFinite(v)) audioVolume = Math.max(0, Math.min(1, v));
      }catch(e){}
    })();

    // Load configured labels from localStorage (numbers)
    function getConfiguredLabels(){
      try{
        const raw = localStorage.getItem('lotto.labels');
        if (!raw) return [];
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr)) return [];
        // keep only finite numbers
        return arr.map(v=>parseInt(v,10)).filter(n=>Number.isFinite(n));
      }catch(e){ return []; }
    }

    // Confetti effect
    const confetti = { parts: [], anim: null, until: 0, running: false };
    function sizeConfetti(){ if (!confettiCanvas) return; confettiCanvas.width = stage.clientWidth; confettiCanvas.height = stage.clientHeight; }
    function spawnConfettiBurst(x, y, count){
      if (!confettiCtx) return;
      const colors = [0,30,50,160,200,280,330].map(h=>`hsl(${h} 90% 60%)`);
      for (let i=0;i<count;i++){
        const a = Math.random()*Math.PI*2;
        const sp = 2 + Math.random()*4;
        confetti.parts.push({
          x, y,
          vx: Math.cos(a)*sp,
          vy: Math.sin(a)*sp - 2 - Math.random()*2,
          g: 0.22 + Math.random()*0.12,
          fr: 0.985,
          w: 4 + Math.random()*6,
          h: 6 + Math.random()*8,
          rot: Math.random()*Math.PI,
          vr: (-0.2 + Math.random()*0.4),
          life: 0,
          ttl: 90 + Math.random()*70,
          color: colors[(Math.random()*colors.length)|0],
          shape: Math.random()<0.75 ? 'rect' : 'circle'
        });
      }
    }
    function stepConfetti(){
      if (!confettiCtx || !confettiCanvas) return;
      const ctx = confettiCtx, W=confettiCanvas.width, H=confettiCanvas.height;
      ctx.clearRect(0,0,W,H);
      let alive = [];
      for (const p of confetti.parts){
        p.life++;
        p.vy += p.g*0.06; // gravity dt
        p.vx *= p.fr; p.vy *= p.fr;
        p.x += p.vx; p.y += p.vy;
        p.rot += p.vr*0.06;
        const offscreen = (p.y > H+30 || p.y < -30 || p.x < -30 || p.x > W+30);
        if (!offscreen && p.life < p.ttl) alive.push(p);
        ctx.save();
        ctx.translate(p.x, p.y); ctx.rotate(p.rot);
        ctx.fillStyle = p.color;
        if (p.shape==='rect') ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h); else { ctx.beginPath(); ctx.arc(0,0, Math.max(2,p.w*0.4), 0, Math.PI*2); ctx.fill(); }
        ctx.restore();
      }
      confetti.parts = alive;
      if (confetti.running){
        if (performance.now() < confetti.until || confetti.parts.length>0) confetti.anim = requestAnimationFrame(stepConfetti);
        else {
          confetti.running = false; confetti.parts = [];
          ctx.clearRect(0,0,W,H);
        }
      }
    }
    function startConfetti(durationMs=2500){
      if (!confettiCanvas) return;
      sizeConfetti();
      confetti.parts = [];
      // spawn around winnerBall center if available
      let cx = stage.clientWidth/2, cy = stage.clientHeight/2 - 40;
      if (winnerBall){
        const r1 = stage.getBoundingClientRect();
        const r2 = winnerBall.getBoundingClientRect();
        cx = (r2.left + r2.right)/2 - r1.left;
        cy = (r2.top + r2.bottom)/2 - r1.top;
      }
      spawnConfettiBurst(cx, cy, 180);
      // side bursts
      spawnConfettiBurst(Math.max(20, cx-120), Math.max(20, cy-60), 80);
      spawnConfettiBurst(Math.min(confettiCanvas.width-20, cx+120), Math.max(20, cy-60), 80);
      confetti.running = true; confetti.until = performance.now() + durationMs;
      cancelAnimationFrame(confetti.anim || 0);
      confetti.anim = requestAnimationFrame(stepConfetti);
    }
    function stopConfetti(){
      if (!confettiCanvas || !confettiCtx) return;
      confetti.running = false; confetti.parts = [];
      cancelAnimationFrame(confetti.anim || 0);
      confettiCtx.clearRect(0,0,confettiCanvas.width,confettiCanvas.height);
    }

    function resetWorld(){
      marbles.forEach(m => Composite.remove(engine.world, m.body));
      // remove labels
      const labels = document.getElementById('labels');
      if (labels) labels.innerHTML = '';
      marbles = [];
      drum.parts.forEach(b => Composite.remove(engine.world, b));
      drum.gate.forEach(b => Composite.remove(engine.world, b));
      drum.basket.forEach(b => Composite.remove(engine.world, b));
      if (drum.sensor) Composite.remove(engine.world, drum.sensor);
      if (drum.plug) Composite.remove(engine.world, drum.plug);
      drum = { parts: [], gate: [], basket: [] };
      drawn = null; gateOpened = false; gateOpenAt = 0; selectedId = null; sensorTime.clear();
      // restore time scale
      if (engine && engine.timing) engine.timing.timeScale = 1;
      slowMoActive = false;
      try { if (slowHoldTimer) { clearTimeout(slowHoldTimer); slowHoldTimer = 0; } } catch(e) {}
      stopSlowHold();
      clearZoom();
      countdownEl.classList.remove('show'); winnerEl.classList.remove('show'); btnDraw.disabled = false;
    }

    function buildDrumAndBasket(rEst){
      const W = render.options.width, H = render.options.height;
      const cx = W/2, cy = H/2 - 40; const R = Math.max(120, Math.min(Math.min(W, H)*drumRatio, 300));
      const segs = 64, thick = 18; // 더 촘촘하고 두껍게
      // Visual plug removed to avoid hiding ball colors inside the drum
      drum.plug = null;

      // 게이트 각도와 필요 개구 폭 계산 (공이 충분히 나갈 수 있도록 반지름 기반 가변 폭)
      const gateAngle = (exitDir === 'right') ? 0 : (Math.PI/2);
      const angleDiff = (a, b) => Math.atan2(Math.sin(a-b), Math.cos(a-b));
      // 공 반지름을 고려한 최소 필요 반각(여유 포함)
      const safeRad = Math.max(8, R - thick*0.6);
      const needTol = Math.asin(Math.min(0.95, (Math.max(10, rEst||12) + 6) / safeRad)); // 여유 +6px
      const baseTol = Math.PI/segs * 2.6; // 기본 폭 약간 증가
      const gateTol = Math.max(baseTol, isFinite(needTol) ? needTol : baseTol);

      // 1st ring layer (게이트를 방향에 맞게 배치)
      for (let i=0;i<segs;i++){
        const a = (i/segs) * Math.PI*2;
        const px = cx + (R - thick*0.5) * Math.cos(a);
        const py = cy + (R - thick*0.5) * Math.sin(a);
        const w = (2*Math.PI*R)/segs + 8; const h = thick;
        const wall = Bodies.rectangle(px, py, w, h, { isStatic: true, angle: a, chamfer: 6, restitution: 1.0, friction: 0.01, render: { fillStyle: '#1c2a44' } });
        const isGate = Math.abs(angleDiff(a, gateAngle)) < gateTol;
        if (isGate) {
          wall.render.fillStyle = '#e11d48'; // 붉은색으로 표시 (닫혀있을 때만 보임)
          wall.render.strokeStyle = '#f43f5e';
          wall.render.lineWidth = 1;
        }
        if (isGate) drum.gate.push(wall); else drum.parts.push(wall);
      }
      // 2nd ring layer (half-segment offset) for 겹침 → 누수 방지
      for (let i=0;i<segs;i++){
        const a = ((i+0.5)/segs) * Math.PI*2;
        const px = cx + (R - thick*0.5) * Math.cos(a);
        const py = cy + (R - thick*0.5) * Math.sin(a);
        const w = (2*Math.PI*R)/segs + 8; const h = thick;
        const wall = Bodies.rectangle(px, py, w, h, { isStatic: true, angle: a, chamfer: 6, restitution: 1.0, friction: 0.01, render: { fillStyle: '#1a2743' } });
        const isGate2 = Math.abs(angleDiff(a, gateAngle)) < gateTol;
        if (isGate2) {
          wall.render.fillStyle = '#e11d48';
          wall.render.strokeStyle = '#f43f5e';
          wall.render.lineWidth = 1;
        }
        if (isGate2) drum.gate.push(wall); else drum.parts.push(wall);
      }
      // Add ring segments
      Composite.add(engine.world, drum.parts);
      Composite.add(engine.world, drum.gate); // start as closed

      // Sensor at gate to mark true exit from drum
      const sensor = exitDir === 'right'
        ? Bodies.rectangle(cx + R + 6, cy, 12, R * 1.2, { isStatic: true, isSensor: true, render: { visible: false } })
        : Bodies.rectangle(cx, cy + R + 6, R * 0.9, 12, { isStatic: true, isSensor: true, render: { visible: false } });
      drum.sensor = sensor; Composite.add(engine.world, sensor);
      
      // Chute depending on exit direction
      const railThickness = 10;
      const railGap = Math.max(56, 2 * (Math.max(10, rEst||12) + 4) + 12); // ensure gap > 2*r + clearance
      if (exitDir === 'right'){
        const railAngle = 0.06; // gentle slope
        const leftGap = Math.max(10, (rEst||12) + 8); // 큰 공일 때 여유 확보
        const railLen = R * 0.25; // half length chute
        const leftX = cx + R + leftGap;
        const upperLeftY = cy - 36; // connect height
        const railX = leftX + (railLen/2) * Math.cos(railAngle);
        const railY = upperLeftY + (railLen/2) * Math.sin(railAngle);
        const upperRail = Bodies.rectangle(railX, railY, railLen, railThickness, { isStatic: true, angle: railAngle, restitution: 0.9, friction: 0.01, render: { fillStyle: '#21314f' } });
        const lowerRail = Bodies.rectangle(railX, railY + railGap, railLen, railThickness, { isStatic: true, angle: railAngle, restitution: 0.9, friction: 0.01, render: { fillStyle: '#21314f' } });
        // vertical end cap
        const endX = railX + (railLen/2) * Math.cos(railAngle);
        const endYUpper = railY + (railLen/2) * Math.sin(railAngle);
        const vCapThickness = 14;
        const vCap = Bodies.rectangle(endX + vCapThickness/2 + 2, endYUpper + railGap/2, vCapThickness, railGap + 16, { isStatic: true, angle: 0, chamfer: 2, restitution: 0.9, friction: 0.01, render: { fillStyle: '#223456' } });
        Composite.add(engine.world, [upperRail, lowerRail, vCap]);
        drum.basket.push(upperRail, lowerRail, vCap);
        drum.chute = { angle: railAngle, start: { x: leftX, y: upperLeftY + railGap/2 }, end: { x: endX, y: endYUpper + railGap/2 } };
      } else {
        // bottom chute: two vertical rails below the gate, with horizontal bottom cap
        const gapFromRim = 10;
        const railLenB = R * 0.3; // half length vertical basket
        const yTop = cy + R + gapFromRim;
        const xLeft = cx - railGap/2;
        const xRight = cx + railGap/2;
        const railXc = cx; const railYc = yTop + railLenB/2;
        const leftRail = Bodies.rectangle(xLeft, railYc, railThickness, railLenB, { isStatic: true, angle: 0, restitution: 0.9, friction: 0.01, render: { fillStyle: '#21314f' } });
        const rightRail = Bodies.rectangle(xRight, railYc, railThickness, railLenB, { isStatic: true, angle: 0, restitution: 0.9, friction: 0.01, render: { fillStyle: '#21314f' } });
        const bottomCap = Bodies.rectangle(cx, yTop + railLenB + 8, railGap + 16, 12, { isStatic: true, angle: 0, restitution: 0.9, friction: 0.01, render: { fillStyle: '#1f2a44' } });
        Composite.add(engine.world, [leftRail, rightRail, bottomCap]);
        drum.basket.push(leftRail, rightRail, bottomCap);
        drum.chute = { angle: Math.PI/2, start: { x: cx, y: yTop }, end: { x: cx, y: yTop + railLenB } };
      }

      // World bounds (top/bottom to catch runaway)
      Composite.add(engine.world, Bodies.rectangle(W/2, H+100, W*2, 200, { isStatic: true, restitution: 0.9, render: { visible: false } }));
      Composite.add(engine.world, Bodies.rectangle(W/2, -100, W*2, 200, { isStatic: true, restitution: 0.9, render: { visible: false } }));

      return { cx, cy, R };
    }

    function estimateBallRadius(R, n){
      // Bigger base size with gentle shrink for high counts
      const base = Math.max(12, Math.min(26, Math.floor(R * 0.07)));
      const shrink = Math.max(0.85, 1 - Math.max(0, n - 16) / 400);
      return Math.round(base * shrink);
    }

    function createMarbles(n, Rinfo){
      const configured = getConfiguredLabels();
      const rEst = estimateBallRadius(Rinfo.R, n);
      for (let i=0;i<n;i++){
        const hue = (i * (360/Math.max(8,n))) % 360; const color = rgb(hue);
        const r = rEst;
        const phi = Math.random()*Math.PI*2; const rad = Math.random() * (Rinfo.R*0.7);
        const x = Rinfo.cx + Math.cos(phi)*rad, y = Rinfo.cy + Math.sin(phi)*rad;
        const m = Bodies.circle(x, y, r, { label: 'marble', density: 0.0004, restitution: 1.0, friction: 0.01, frictionAir: 0.0015, render: { fillStyle: color, strokeStyle: '#0a0a0a', lineWidth: 1 } });
        const displayId = configured.length ? configured[i % configured.length] : (i+1);
        const item = { body: m, id: displayId };
        marbles.push(item); Composite.add(engine.world, m);
        // create label
        const labels = document.getElementById('labels');
        if (labels){
          const el = document.createElement('div');
          el.className = 'm-label';
          el.textContent = String(displayId);
          el.style.position = 'absolute';
          el.style.transform = 'translate(-50%, -50%)';
          el.style.fontWeight = '900';
          // Remove white circle badge: show number only with slight shadow
          el.style.color = '#f9fafb';
          el.style.background = 'transparent';
          el.style.border = 'none';
          el.style.boxShadow = 'none';
          el.style.display = 'block';
          el.style.textShadow = '0 1px 2px rgba(0,0,0,.85), 0 0 3px rgba(0,0,0,.6)';
          el.style.borderRadius = '0';
          // scale label to ~50% of ball diameter (show ball color around)
          const d = Math.max(12, Math.round(r));
          // keep font size scaled to ball, no badge sizing
          el.style.fontSize = Math.max(12, Math.floor(r * 0.85)) + 'px';
          // 초기 위치를 공 위치로 설정 (왼쪽 상단 몰림 방지)
          el.style.left = x + 'px';
          el.style.top = y + 'px';
          labels.appendChild(el);
          // 공 래퍼와 바디 모두에 참조 저장
          item.labelEl = el; // wrapper 참조
          m.labelEl = el;    // body 참조
        }
      }
    }

    function openGate(){
      // 게이트 세그먼트를 물리적으로 통과 가능하게 전환 + 시각적으로 숨김
      drum.gate.forEach(b => {
        b.isSensor = true;
        b.render.visible = false;
        if (b.collisionFilter) {
          b.collisionFilter.mask = 0; // 어떤 바디와도 충돌하지 않음
        }
      });
      if (drum.plug) drum.plug.render.visible = false; // reveal interior when open
      gateOpened = true; gateOpenAt = performance.now(); selectedId = null; sensorTime.clear();
    }
    function closeGate(){
      drum.gate.forEach(b => {
        b.isSensor = false;
        b.render.visible = true;
        if (b.collisionFilter) {
          b.collisionFilter.mask = 0xFFFFFFFF; // 기본 복원
        }
      });
      if (drum.plug) drum.plug.render.visible = true; gateOpened = false;
    }

    // Winner detection: marble below basket floor line
    // winner by collision with basket floor after passing gate sensor
function showWinner(m){
  if (drawn) return;
  drawn = m;
  winnerBall.style.background = drawn.body.render.fillStyle;
  winnerBall.textContent = String(drawn.id);
  winnerEl.classList.add('show');
  btnDraw.disabled = true;
  startConfetti(2800);
  ensureAudio();
  playFanfare();
  // keep zoom a bit during the win moment, then reset; keep slow-mo ~1s
  try { if (slowHoldTimer) { clearTimeout(slowHoldTimer); slowHoldTimer = 0; } } catch(e) {}
  try { setTimeout(() => { try { clearZoom(); } catch(e) {} }, 400); } catch(e) {}
  // keep slow motion about ~1s more, then release
  try { if (slowHoldTimer) { clearTimeout(slowHoldTimer); slowHoldTimer = 0; } } catch(e) {}
  try { slowHoldTimer = setTimeout(() => { try { stopSlowHold(); } catch(e) {} slowHoldTimer = 0; }, 1000); } catch(e) {}
  // safety: ensure gate closes shortly after winner, in case sensor-based close missed
  try { setTimeout(() => { try { closeGate(); } catch(e) {} }, 450); } catch(e) {}
  // 게이트 닫기는 afterUpdate에서 바구니 끝 근처에서 처리
  // stop wind after winner selected
  running = false;
}

    function hideWinnerOverlay(){
      if (!winnerEl.classList.contains('show')) return;
      winnerEl.classList.remove('show');
      stopConfetti();
    }

    function beginCountdown(sec, after){
      let r = sec; countdownEl.textContent = r; countdownEl.classList.add('show');
      clearInterval(countdownTimer);
      // start tension
      countdownActive = true; countdownEnd = performance.now() + sec*1000; countdownTotal = sec; lastWhole = r; if (tensionEl) tensionEl.style.opacity = '0.12';
      countdownTimer = setInterval(() => {
        r--; if (r<0) r=0;
        countdownEl.textContent = r; countdownEl.classList.add('tick'); setTimeout(()=>countdownEl.classList.remove('tick'), 260);
        ensureAudio(); if (audioCtx){ const f = 520 + (countdownTotal - r) * 60; beep(r===0? 1200 : f, r===0? 220:110, r<=3? 0.09:0.05); }
        if (r<=0){
          clearInterval(countdownTimer);
          countdownEl.classList.remove('show'); countdownActive = false; countdownBoost = 0; if (tensionEl) tensionEl.style.opacity='0';
          // zoom to exit and hold slow-mo until winner
          try { startZoomToExit(1.28, 900); } catch(e) {}
          try { startSlowHold(0.28); } catch(e) {}
          after();
        }
      }, 1000);
    }

    function randomKick(){ if (!running) return; for (const m of marbles){ const k = 0.002; Body.applyForce(m.body, m.body.position, { x: (Math.random()-0.5)*k, y: (Math.random()-0.5)*k }); } }

    // Controls
    let Rinfo = null;
    function getConfiguredCount(){
      const raw = localStorage.getItem('lotto.count');
      const v = parseInt(raw||'',10);
      return Number.isFinite(v) ? v : 24;
    }

    function generate(){
      resetWorld();
      // decide count first
      const configured = getConfiguredLabels();
      let n = configured.length ? configured.length : getConfiguredCount();
      n = Math.max(1, Math.min(200, n));
      // estimate radius to size the chute gap accordingly
      const W = render.options.width, H = render.options.height;
      const Rcur = Math.max(120, Math.min(Math.min(W, H)*drumRatio, 300));
      const rEst = estimateBallRadius(Rcur, n);
      Rinfo = buildDrumAndBasket(rEst);
      // update drum decor overlay to match drum size/position
      try{
        const frame = document.getElementById('drumFrame');
        const glass = document.getElementById('drumGlass');
        if (frame && glass){
          const size = Math.round(Rinfo.R * 2);
          frame.style.left = Rinfo.cx + 'px';
          frame.style.top = Rinfo.cy + 'px';
          frame.style.width = size + 'px';
          frame.style.height = size + 'px';
          // inner glass slightly smaller
          const gsize = Math.round(size - 10);
          glass.style.left = Rinfo.cx + 'px';
          glass.style.top = (Rinfo.cy - 2) + 'px';
          glass.style.width = gsize + 'px';
          glass.style.height = gsize + 'px';
          glass.style.boxShadow = 'inset 0 0 30px rgba(255,255,255,.05)';
        }
      }catch(e){}
      // brand logo load
      try{
        const data = localStorage.getItem('lotto.logoData');
        if (brandLogo){ if (data){ brandLogo.src = data; brandLogo.style.display='block'; } else { brandLogo.style.display='none'; } }
      }catch(e){}
      createMarbles(n, Rinfo);
      closeGate();
      // wind off after generating
      running = false;
    }
    if (btnGen) btnGen.addEventListener('click', generate);
    if (btnStart) btnStart.addEventListener('click', () => { running = true; });
    if (btnDraw) btnDraw.addEventListener('click', () => {
      ensureAudio();
      running = true;
      beginCountdown(10, () => { openGate(); });
    });

    // Wind control
    (function(){
      const el = document.getElementById('wind');
      if (el) {
        const toStrength = () => Math.max(0, Math.min(1, Number(el.value||0)/100));
        windStrength = toStrength();
        el.addEventListener('input', () => { windStrength = toStrength(); });
      }
    })();

    // Loop: wind (bottom upward, top lateral: L=CCW, R=CW) + random kicks
    Events.on(engine, 'afterUpdate', () => {
      // countdown tension visuals and boost
      if (countdownActive){
        const nowMs = performance.now();
        const remain = Math.max(0, countdownEnd - nowMs);
        const p = 1 - Math.min(1, remain / (countdownTotal*1000));
        countdownBoost = p; // 0..1
        if (tensionEl){ tensionEl.style.opacity = String(0.12 + 0.28 * p); }
        // subtle shake last 3s, composed with zoom scale
        let sx = 0, sy = 0;
        if (remain < 3000){ const k = 1 - (remain/3000); const amp = 3 * k; sx = (Math.random()-0.5)*amp; sy = (Math.random()-0.5)*amp; }
        // ensure transform origin when zooming
        if (stage){
          if (zoomActive && zoomOrigin){ stage.style.transformOrigin = `${zoomOrigin.x}px ${zoomOrigin.y}px`; }
          // zScale computed later; temp placeholder replaced below
        }
      } else {
        countdownBoost = 0; if (tensionEl) tensionEl.style.opacity='0';
        // keep zoom transform if active; otherwise reset handled below
      }
      // slow motion easing
      if (slowMoActive){
        const t = performance.now() - slowMoStart;
        if (t < slowMoDur){
          const k = Math.max(0, Math.min(1, t / slowMoDur));
          engine.timing.timeScale = slowMoMin + (1 - slowMoMin) * k;
        } else {
          engine.timing.timeScale = 1;
          slowMoActive = false;
        }
      }
      // force slow-mo hold until winner (clamp)
      if (slowHoldActive){
        engine.timing.timeScale = Math.min(engine.timing.timeScale || 1, slowHoldScale);
      }
      // camera zoom to exit (ramp up then hold)
      let zScale = 1;
      if (zoomActive){
        const t = Math.max(0, performance.now() - zoomStart);
        const k = Math.min(1, t / Math.max(1, zoomDur));
        zScale = zoomFrom + (zoomTo - zoomFrom) * k;
        if (stage && zoomOrigin) stage.style.transformOrigin = `${zoomOrigin.x}px ${zoomOrigin.y}px`;
      }
      // apply composed transform (shake from countdown + persistent zoom)
      if (stage){
        // reconstruct shake similar to above to avoid duplication
        let sx = 0, sy = 0;
        if (countdownActive){
          const nowMs = performance.now();
          const remain = Math.max(0, countdownEnd - nowMs);
          if (remain < 3000){ const k = 1 - (remain/3000); const amp = 3 * k; sx = (Math.random()-0.5)*amp; sy = (Math.random()-0.5)*amp; }
        }
        stage.style.transform = (sx!==0 || sy!==0) ? `translate(${sx}px,${sy}px) scale(${zScale})` : (zoomActive ? `scale(${zScale})` : '');
      }
      const now = engine.timing.timestamp;
      if (running && Rinfo){
        for (const m of marbles){
          const pos = m.body.position;
          const mass = m.body.mass;
          const dx = pos.x - Rinfo.cx;
          const dy = pos.y - Rinfo.cy;
          const dist = Math.hypot(dx, dy) + 1e-6;
          const nx = dx / dist, ny = dy / dist;
          // Tangential (swirl) direction around center
          const tx = -ny, ty = nx;

          // Normalized position
          const relX = dx / Rinfo.R;     // left<0, right>0
          const relY = dy / Rinfo.R;     // bottom>0, top<0

          // Bottom upward: 바닥 정체 방지 (살짝 강화)
          const bottomFactor = Math.max(0, (relY - 0.05) / 0.95);
          const liftBase = -0.0022 * windStrength;
          const liftBottom = -0.0028 * windStrength * bottomFactor;
          const fY_up = (liftBase + liftBottom) * mass;

          // Global clockwise swirl around center (시계 방향 고정, 전 구역 적용)
          const rimFactor = Math.min(1, dist / Rinfo.R);
          const windEff = Math.pow(windStrength, 1.15) * 2.2; // 최대 훨씬 강하게, 저레벨은 완만
          let swirlMag = 0.0022 * windEff * (0.4 + 0.6 * rimFactor);
          // countdown boost slightly intensifies swirl for tension
          if (countdownBoost>0) swirlMag *= (1 + 0.4 * countdownBoost);
          swirlMag = Math.min(swirlMag, 0.0045); // 상한으로 이상 가속 방지
          const cwTx = ny, cwTy = -nx; // CW 방향 접선 벡터

          // Gentle noise for mixing (약하게)
          const gentle = 0.0002 * windStrength * Math.sin((now * 0.004) + dy * 0.02);

          // Skip extra swirl forces for selected winner to let it glide
          if (!(selectedId !== null && m.body.id === selectedId)){
            const fx = (swirlMag * cwTx + gentle * tx) * mass;
            const fy = (fY_up + gentle * ty + swirlMag * cwTy) * mass;
            Body.applyForce(m.body, pos, { x: fx, y: fy });
          }

          // Anti-crawl nudge near bottom edge (stronger & wider band)
          if (relY > 0.4 && m.body.speed < 1.6 && !(selectedId !== null && m.body.id === selectedId)) {
            Body.applyForce(m.body, pos, { x: 0, y: -0.045 * mass });
          }

          // Micro jitter each frame to de-clump and add liveliness (disabled for selected winner)
          if (running && selectedId === null){
            const j = 0.0008 * (0.5 + windStrength) * mass;
            Body.applyForce(m.body, pos, { x: (Math.random()-0.5) * j, y: (Math.random()-0.5) * j });
          }

          // Clamp excessive velocity to avoid tunneling/escape (allow faster spin)
          if (m.body.speed > 10){
            const k = 10 / m.body.speed;
            Body.setVelocity(m.body, { x: m.body.velocity.x * k, y: m.body.velocity.y * k });
          }
          // Anti-crawl nudge near bottom
          if (relY > 0.7 && m.body.speed < 0.4 && !(selectedId !== null && m.body.id === selectedId)) Body.applyForce(m.body, pos, { x: 0, y: -0.02 * mass });
        }
        // 게이트 오픈 후(오른쪽 관으로) 한 개가 선택될 때까지 흡입 (혼잡 방지: 가장 가까운 공만 타겟)
        if (gateOpened){
          let hole = exitDir === 'right' ? { x: Rinfo.cx + Rinfo.R + 8, y: Rinfo.cy } : { x: Rinfo.cx, y: Rinfo.cy + Rinfo.R + 8 };
          if (drum.chute && drum.chute.start){ hole = { x: drum.chute.start.x, y: drum.chute.start.y }; }
          if (selectedId === null){
            // 아직 선정 전: 가장 가까운 공 하나만 흡입 + 주변 분산
            let best = null, bestD = Infinity;
            for (const m of marbles){
              const dxh = hole.x - m.body.position.x;
              const dyh = hole.y - m.body.position.y;
              const d = Math.hypot(dxh, dyh);
              if (d < bestD){ bestD = d; best = m; }
            }
            for (const m of marbles){
              const dxh = hole.x - m.body.position.x;
              const dyh = hole.y - m.body.position.y;
              const d = Math.hypot(dxh, dyh) + 1e-6;
              const nxh = dxh / d, nyh = dyh / d;
              if (m === best){
                const dNorm = Math.min(1, d / (Rinfo.R * 1.2));
                const pull = (0.001 + 0.006 * dNorm) * (0.6 + 0.4*windStrength) * m.body.mass;
                Body.applyForce(m.body, m.body.position, { x: nxh * pull, y: nyh * pull });
              } else if (d < 80){
                const repel = 0.0008 * m.body.mass;
                Body.applyForce(m.body, m.body.position, { x: -nxh * repel, y: -nyh * repel });
              }
            }
          } else {
            // 선정된 공: 1) 게이트 쪽으로 충분히 빼내고 2) 통로 끝쪽으로 스르르 이동
            const sel = marbles.find(mm => mm.body.id === selectedId);
            if (sel){
              // 1) 게이트 입구에서 확실히 추출
              const dxh = hole.x - sel.body.position.x;
              const dyh = hole.y - sel.body.position.y;
              const d = Math.hypot(dxh, dyh) + 1e-6;
              const nxh = dxh / d, nyh = dyh / d;
              const pull = 0.006 * sel.body.mass; // 더 완만한 추출력
              Body.applyForce(sel.body, sel.body.position, { x: nxh * pull, y: nyh * pull });
              // 게이트 닫기: 센서에서 충분히 벗어나면(반지름+여유) 닫기
              if (awaitingExit && gateOpened){
                const rSel = sel.body.circleRadius || 12;
                if (exitDir === 'right'){
                  const sx = (drum.sensor && drum.sensor.position ? drum.sensor.position.x : (Rinfo.cx + Rinfo.R));
                  if (sel.body.position.x > sx + rSel + 6){ closeGate(); awaitingExit = false; }
                } else {
                  const sy = (drum.sensor && drum.sensor.position ? drum.sensor.position.y : (Rinfo.cy + Rinfo.R));
                  if (sel.body.position.y > sy + rSel + 6){ closeGate(); awaitingExit = false; }
                }
              }

              // 2) 통로 끝으로 부드럽게 미는 힘
              if (drum.chute && drum.chute.end){
                const end = drum.chute.end;
                const dxe = end.x - sel.body.position.x;
                const dye = end.y - sel.body.position.y;
                const de = Math.hypot(dxe, dye) + 1e-6;
                const nxe = dxe / de, nye = dye / de;
                const glide = Math.min(0.006, 0.002 + 0.004 * (de / (Rinfo.R)) ) * sel.body.mass;
                Body.applyForce(sel.body, sel.body.position, { x: nxe * glide, y: nye * glide });
              }
          }
        }
      }
      }
      // 항상 라벨 위치 동기화 (시작 전에도 공 위에 표시)
      for (const m of marbles){
        const el = (m && m.labelEl) || (m.body && m.body.labelEl);
        if (el){
          const pos = m.body.position;
          el.style.left = pos.x + 'px';
          el.style.top = pos.y + 'px';
        }
      }
      if (running && now % 60 < 16) randomKick();
    });

    // Mark marbles that actually exit through the gate sensor
    Events.on(engine, 'collisionStart', (e) => {
      for (const pair of e.pairs){
        const { bodyA, bodyB } = pair;
        const isSensorA = drum.sensor && bodyA === drum.sensor;
        const isSensorB = drum.sensor && bodyB === drum.sensor;
        if (isSensorA || isSensorB){
          const other = isSensorA ? bodyB : bodyA;
          // find marble by body id
          const found = marbles.find(m => m.body === other);
          if (found && gateOpened){
            sensorTime.set(found.body.id, performance.now());
            if (selectedId === null){
              // 첫 번째 통과 공만 후보로 지정하고 곧바로 문 닫기
              selectedId = found.body.id;
              awaitingExit = true; // 관으로 충분히 나갈 때까지 대기 후 문 닫기
              // slow motion moment when entering the winning hole
              triggerSlowMo(0.25, 1200);
              // zoom into exit while slow motion plays
              startZoomToExit(1.28, 900);
            }
          }
        }
    // Winner trigger: first marble that passed the top sensor after gate open
    if ((isSensorA || isSensorB) && selectedId !== null){
      const other = isSensorA ? bodyB : bodyA;
      const found = marbles.find(m => m.body === other);
      const tPass = found ? sensorTime.get(found.body.id) : undefined;
      if (found && found.body.label === 'marble' && found.body.id === selectedId && tPass && tPass >= gateOpenAt + 50) {
        showWinner(found);
      }
    }
      }
    });

    // Resize
    function onResize(){
      const W = stage.clientWidth, H = stage.clientHeight;
      const pr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      if (Matter.Render && Matter.Render.setPixelRatio) Matter.Render.setPixelRatio(render, pr);
      render.canvas.width = W * pr; render.canvas.height = H * pr;
      render.canvas.style.width = W + 'px'; render.canvas.style.height = H + 'px';
      render.options.width = W; render.options.height = H;
      sizeConfetti();
      generate();
    }
    window.addEventListener('resize', onResize);

    // init
    sizeConfetti();
    onResize();
    // image upload (click preview area to trigger)
    if (uploadInput && previewImg){
      // image load
      uploadInput.addEventListener('change', (e) => {
        const f = uploadInput.files && uploadInput.files[0];
        if (!f) return;
        const url = URL.createObjectURL(f);
        // Use background for panning on both axes
        if (previewWrap){
          previewWrap.style.backgroundImage = `url('${url}')`;
          if (previewImg) previewImg.style.display = 'none';
          imagePos = { x: 50, y: 50 };
          applyImagePos();
          saveImagePos();
        } else {
          // fallback: still set img
          previewImg.src = url;
          previewImg.style.objectFit = 'cover';
          imagePos = { x: 50, y: 50 };
          applyImagePos();
          saveImagePos();
        }
      });
      if (previewWrap){
        // click to upload only when no image yet
        previewWrap.addEventListener('click', (e) => {
          if (!previewImg.getAttribute('src')) uploadInput.click();
        });
        // drag & drop upload
        const setDragStyle = (on)=>{
          previewWrap.style.borderColor = on ? 'rgba(147,197,253,.9)' : 'rgba(255,255,255,.15)';
          previewWrap.style.backgroundColor = on ? 'rgba(30,58,138,.25)' : 'rgba(0,0,0,.15)';
        };
        ['dragenter','dragover'].forEach(evt=>{
          previewWrap.addEventListener(evt, (e)=>{ e.preventDefault(); e.stopPropagation(); if (e.dataTransfer) e.dataTransfer.dropEffect='copy'; setDragStyle(true); });
        });
        ['dragleave','dragend'].forEach(evt=>{
          previewWrap.addEventListener(evt, (e)=>{ e.preventDefault(); e.stopPropagation(); setDragStyle(false); });
        });
        previewWrap.addEventListener('drop', (e)=>{
          e.preventDefault(); e.stopPropagation(); setDragStyle(false);
          const dt = e.dataTransfer; if (!dt) return;
          const files = dt.files && dt.files.length ? Array.from(dt.files) : [];
          const f = files.find(ff => ff.type && ff.type.startsWith('image/'));
          if (!f) return;
          const url = URL.createObjectURL(f);
          previewWrap.style.backgroundImage = `url('${url}')`;
          if (previewImg) previewImg.style.display = 'none';
          imagePos = { x: 50, y: 50 };
          applyImagePos();
          saveImagePos();
        });
      }
    }

    // Image position state
    let imagePos = { x: 50, y: 50 };
    function applyImagePos(){
      if (previewWrap && previewWrap.style.backgroundImage){
        previewWrap.style.backgroundPosition = imagePos.x + '% ' + imagePos.y + '%';
      } else if (previewImg) {
        previewImg.style.objectPosition = imagePos.x + '% ' + imagePos.y + '%';
      }
    }
    function saveImagePos(){ try{ localStorage.setItem('lotto.imagePos', JSON.stringify(imagePos)); }catch(e){} }
    (function(){
      // load saved position
      try{ const s = localStorage.getItem('lotto.imagePos'); if (s){ const p = JSON.parse(s); if (typeof p.x==='number' && typeof p.y==='number'){ imagePos = { x: p.x, y: p.y }; applyImagePos(); } } }catch(e){}
      // drag to pan when image exists
      if (!previewWrap) return;
      let dragging = false; let sx=0, sy=0; let startPos = null; let moved = false;
      function onMove(e){
        if (!dragging) return;
        const pt = e.touches ? e.touches[0] : e;
        const dx = pt.clientX - sx; const dy = pt.clientY - sy;
        if (Math.abs(dx)+Math.abs(dy) > 2) moved = true;
        // convert pixels to percent based on wrapper size
        const rect = previewWrap.getBoundingClientRect();
        const dpctX = (dx / rect.width) * 100;
        const dpctY = (dy / rect.height) * 100;
        imagePos = { x: Math.max(0, Math.min(100, (startPos.x + dpctX))), y: Math.max(0, Math.min(100, (startPos.y + dpctY))) };
        applyImagePos();
        e.preventDefault();
      }
      function onUp(e){
        if (!dragging) return;
        dragging = false;
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
        document.removeEventListener('touchmove', onMove);
        document.removeEventListener('touchend', onUp);
        if (moved) saveImagePos();
      }
      previewWrap.addEventListener('mousedown', (e)=>{
        const hasBg = !!(previewWrap.style.backgroundImage && previewWrap.style.backgroundImage !== 'none');
        if (!hasBg && !previewImg.getAttribute('src')) return; // no image
        dragging = true; moved = false; const pt=e; sx=pt.clientX; sy=pt.clientY; startPos = { ...imagePos };
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
      });
      previewWrap.addEventListener('touchstart', (e)=>{
        const hasBg = !!(previewWrap.style.backgroundImage && previewWrap.style.backgroundImage !== 'none');
        if (!hasBg && !previewImg.getAttribute('src')) return;
        dragging = true; moved = false; const pt=e.touches[0]; sx=pt.clientX; sy=pt.clientY; startPos = { ...imagePos };
        document.addEventListener('touchmove', onMove, { passive:false });
        document.addEventListener('touchend', onUp);
      }, { passive:true });
      // double click/tap to reset
      previewWrap.addEventListener('dblclick', ()=>{ imagePos = {x:50, y:50}; applyImagePos(); saveImagePos(); });
    })();

    // Open settings page
    // Settings modal logic
    function parseList(s){ return s.split(/[\n,]+/).map(v=>v.trim()).filter(Boolean).map(v=>parseInt(v,10)).filter(n=>Number.isFinite(n)); }
    function loadSettingsForm(){
      try{
        const saved = localStorage.getItem('lotto.labels');
        if (saved){ const arr = JSON.parse(saved); stNumbers.value = Array.isArray(arr) ? arr.join(', ') : ''; }
        const cnt = localStorage.getItem('lotto.count');
        if (cnt) stCount.value = String(parseInt(cnt,10)||24);
        else stCount.value = (inputCount && inputCount.value) ? inputCount.value : '24';
        // exit dir
        try{ const d = localStorage.getItem('lotto.exitDir'); if (d==='right'||d==='bottom') exitDir = d; }catch(e){}
        if (stExitDir) stExitDir.value = exitDir;
        // volume
        try{ const v = parseFloat(localStorage.getItem('lotto.audioVol')||''); if (Number.isFinite(v)) audioVolume = Math.max(0, Math.min(1, v)); }catch(e){}
        if (stVolume) stVolume.value = String(Math.round((audioVolume||0)*100));
      }catch(e){}
    }
    function saveSettings(){
      const arr = parseList(stNumbers.value);
      localStorage.setItem('lotto.labels', JSON.stringify(arr));
      const n = Math.max(1, Math.min(200, parseInt(stCount.value,10)||24));
      localStorage.setItem('lotto.count', String(n));
      if (inputCount) inputCount.value = String(n);
      // exit dir
      if (stExitDir){ const v = stExitDir.value; exitDir = (v==='bottom')?'bottom':'right'; localStorage.setItem('lotto.exitDir', exitDir); }
      // volume
      if (stVolume){ const v = Math.max(0, Math.min(100, parseInt(stVolume.value,10)||0)); audioVolume = v/100; localStorage.setItem('lotto.audioVol', String(audioVolume)); }
    }
    function openSettings(){ loadSettingsForm(); settingsModal.classList.add('show'); document.body.style.overflow='hidden'; }
    function closeSettings(){ settingsModal.classList.remove('show'); document.body.style.overflow=''; }
    if (btnOpenSettings) btnOpenSettings.addEventListener('click', openSettings);
    if (settingsClose) settingsClose.addEventListener('click', closeSettings);
    if (settingsModal) settingsModal.addEventListener('click', (e)=>{ if (e.target === settingsModal) closeSettings(); });
    if (stSave) stSave.addEventListener('click', ()=>{ saveSettings(); alert('저장되었습니다. "생성"을 누르면 반영됩니다.'); closeSettings(); });
    if (stSaveAndGen) stSaveAndGen.addEventListener('click', ()=>{ saveSettings(); generate(); closeSettings(); });
    if (stClear) stClear.addEventListener('click', ()=>{ localStorage.removeItem('lotto.labels'); stNumbers.value=''; alert('목록이 비워졌습니다.'); });
    if (stFill) stFill.addEventListener('click', ()=>{ const n = Math.max(1, Math.min(200, parseInt(stCount.value,10)||24)); const arr = Array.from({length:n}, (_,i)=>i+1); stNumbers.value = arr.join(', '); });

    // Dismiss winner overlay on click
    if (winnerEl){ winnerEl.addEventListener('click', hideWinnerOverlay); }

    // Test sound for volume preview
    if (stTestSound){
      stTestSound.addEventListener('click', ()=>{
        ensureAudio();
        const prev = audioVolume;
        const vol = stVolume ? Math.max(0, Math.min(1, (parseInt(stVolume.value,10)||0)/100)) : prev;
        audioVolume = vol;
        // short preview: two beeps + mini chord
        beep(660, 120, 0.12);
        setTimeout(()=> beep(880, 140, 0.12), 160);
        setTimeout(()=> {
          // tiny fanfare chord
          try{ playFanfare(); }catch(e){}
          // restore after short delay
          setTimeout(()=>{ audioVolume = prev; }, 900);
        }, 360);
      });
    }

    // Brand logo upload/clear in settings
    if (stLogo){
      stLogo.addEventListener('change', ()=>{
        const f = stLogo.files && stLogo.files[0]; if (!f) return;
        const reader = new FileReader();
        reader.onload = () => { try{ localStorage.setItem('lotto.logoData', reader.result); if (brandLogo){ brandLogo.src = reader.result; brandLogo.style.display='block'; } }catch(e){} };
        reader.readAsDataURL(f);
      });
    }
    if (stClearLogo){
      stClearLogo.addEventListener('click', ()=>{ try{ localStorage.removeItem('lotto.logoData'); if (brandLogo){ brandLogo.removeAttribute('src'); brandLogo.style.display='none'; } }catch(e){} });
    }

    // Resizable split: drag divider to change left pane width
    (function(){
      if (!divider || !leftPane || !contentEl) return;
      let dragging = false; let startX = 0; let startW = 0;
      function onMove(e){
        if (!dragging) return;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const dx = clientX - startX;
        const contentRect = contentEl.getBoundingClientRect();
        const minLeft = 240; const dividerW = divider.getBoundingClientRect().width || 6; const minStage = 380;
        let w = Math.max(minLeft, Math.min(startW + dx, contentRect.width - minStage - dividerW));
        leftPane.style.width = w + 'px';
      }
      function onUp(){
        if (!dragging) return;
        dragging = false;
        document.body.style.userSelect = '';
        document.body.style.cursor = '';
        // update stage/canvas sizing
        try{ onResize(); }catch(err){}
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
        window.removeEventListener('touchmove', onMove);
        window.removeEventListener('touchend', onUp);
      }
      divider.addEventListener('mousedown', (e)=>{
        dragging = true; startX = e.clientX; startW = leftPane.getBoundingClientRect().width;
        document.body.style.userSelect = 'none';
        document.body.style.cursor = 'col-resize';
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
      });
      divider.addEventListener('touchstart', (e)=>{
        dragging = true; startX = e.touches[0].clientX; startW = leftPane.getBoundingClientRect().width;
        document.body.style.userSelect = 'none';
        window.addEventListener('touchmove', onMove, { passive:false });
        window.addEventListener('touchend', onUp);
      }, { passive:true });
    })();

    // Headline: single-line auto-fit font size
    (function(){
      if (!headlineInput) return;
      const measure = document.createElement('span');
      Object.assign(measure.style, { position:'absolute', visibility:'hidden', whiteSpace:'nowrap', left:'-9999px', top:'-9999px', pointerEvents:'none' });
      document.body.appendChild(measure);
      function fitHeadline(){
        const text = (headlineInput.value || '').replace(/\n+/g,' ');
        if (text !== headlineInput.value) headlineInput.value = text;
        const cs = getComputedStyle(headlineInput);
        const padH = parseFloat(cs.paddingLeft)||0 + parseFloat(cs.paddingRight)||0;
        const padV = parseFloat(cs.paddingTop)||0 + parseFloat(cs.paddingBottom)||0;
        const targetW = Math.max(10, headlineInput.clientWidth - padH);
        const targetH = Math.max(10, headlineInput.clientHeight - padV);
        // binary search font size
        let lo = 12, hi = Math.max(18, Math.min(80, targetH*0.9)), best = lo;
        // configure measure font properties
        measure.style.fontFamily = cs.fontFamily;
        measure.style.fontWeight = cs.fontWeight;
        measure.style.letterSpacing = cs.letterSpacing;
        measure.style.wordSpacing = cs.wordSpacing;
        measure.textContent = text || (headlineInput.getAttribute('placeholder') || '');
        for (let i=0;i<12;i++){
          const mid = (lo+hi)/2;
          measure.style.fontSize = mid + 'px';
          const w = measure.offsetWidth;
          if (w <= targetW){ best = mid; lo = mid; } else { hi = mid; }
        }
        headlineInput.style.fontSize = Math.max(12, Math.floor(best)) + 'px';
        headlineInput.style.lineHeight = Math.ceil(Math.min(targetH, best*1.2)) + 'px';
      }
      headlineInput.addEventListener('input', fitHeadline);
      window.addEventListener('resize', fitHeadline);
      fitHeadline();
    })();
  })();
  </script>
</body>
</html>
